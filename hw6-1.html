<html>
    <head>
    <style>
        		#info {
		  position: absolute;
		  top: 10px;
		  width: 100%;
		  padding: 10px;
		  text-align: center;
		  color: #ffff00
		}
		body {
		  overflow: hidden;
		}
    </style>
</head>

<body>
    <div id="info">
        HW6-1
        <p id='msg'></p>
    </div>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/108/three.min.js"></script>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://threejs.org/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://threejs.org/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/geometries/TeapotBufferGeometry.js"></script>
	
	<script id="myVertexShader-mono" type="x-shader/x-vertex">
  varying vec2 vUv; 
  void main() { 
     gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0); 
     vUv = uv; 
  }
</script>
<script id="myFragmentShader-mono" type="x-shader/x-fragment">
  uniform sampler2D texture; 
  varying vec2 vUv; 
  
  vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
  }
  vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
  }
  
  void main() { 
  	vec3 color = texture2D (texture, vUv).rgb;
  	vec3 hh = rgb2hsv (color);
  	hh.y = 0.0;  // set saturation to 0
  	vec3 cc = hsv2rgb (hh);
  	gl_FragColor = vec4 (cc, 1.0); 
  }
</script>
    
    <script id="myVertexShader" type="x-shader/x-vertex">
        uniform vec3 lightpos;
        varying float ndotl;
        varying vec3 lightdir;
        varying vec3 eyenorm;
        void main() {
            gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);
            //vec4 worldpos = modelMatrix * vec4 (position, 1.0);
            //ndotl = dot (normalize(lightpos.xyz - worldpos.xyz), normal);
            vec4 eyepos = modelViewMatrix * vec4 (position, 1.0);
            vec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);
            lightdir = lighteye.xyz - eyepos.xyz;
            eyenorm = normalMatrix * normal;
        }
    </script>
    <script id="myFragmentShader" type="x-shader/x-fragment">
        varying float ndotl;
        varying vec3 lightdir;
        varying vec3 eyenorm;
        vec3 diffuse;
        void main() {
            float nn = dot (normalize(lightdir), normalize(eyenorm));
            if (nn > 0.8) {
                nn= 1.0;
            } else if (nn > 0.6) {
                nn = 0.6;
            } else {
                nn = 0.2;
            }
            diffuse = vec3(199.0/255.0 , 242.0/255.0 , 255.0/255.0);//light blue
            //diffuse = vec3(255.0/255.0 , 246.0/255.0 , 199.0/255.0); //light yellow
            gl_FragColor = vec4 (diffuse*nn, 1.0);
        }
    </script>
    
    <script id="myVertexShader-mono" type="x-shader/x-vertex">
      varying vec2 vUv; 
      void main() { 
         gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0); 
         vUv = uv; 
      }
    </script>
    <script id="myFragmentShader-mono" type="x-shader/x-fragment">
      uniform sampler2D texture; 
      uniform vec2 imageSize;
      varying vec2 vUv; 
      //float step_w = 1.0/imageSize.x; 
      //float step_h = 1.0/imageSize.y; 
      vec3 rgb2hsv(vec3 c) {
        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
        float d = q.x - min(q.w, q.y);
        float e = 1.0e-10;
        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
      }
      vec3 hsv2rgb(vec3 c) {
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
      }
      void main() { 
        vec3 color = texture2D (texture, vUv).rgb;
        vec3 hh = rgb2hsv (color);
        hh.y = 0.0;
        vec3 cc = hsv2rgb (hh);
        gl_FragColor = vec4 (cc, 1.0); 
      }
    </script>

    <script>
	javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='https://mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()

        var camera, sceneGrey, renderer, controls;
        var raycaster, desk_light;
        var mouse = new THREE.Vector2();
        var pickables = [];
        var desklamp_switch_core, desklamp_switch;
        var roomlight_switch_core, roomlight_switch;
        var lit = true, roomlit = true;
        var ambient, directionalLight;
        var materialArray;
        var theObjectAll, theObjectPencil, theObjectChair;
        var sphere;
        var desk_things, desk_entrys;
		var byab = [0.3, 0.6, 0.7, 0.6];
        
        class Ball_light {
            constructor() {
                this.pos = new THREE.Vector3(-20, 40, -10);
                this.mesh = new THREE.Object3D();
                this.light = new THREE.PointLight();
            }
        }
        class Desk {
            constructor() {
                this.pos = new THREE.Vector3();
            }
        }
        
        init();
        animate();
        function unitize (object, x, y, z,targetSize) {  
            var box3 = new THREE.Box3();
            box3.setFromObject (object);
            var size = new THREE.Vector3();
            size.subVectors (box3.max, box3.min);
            var center = new THREE.Vector3();
            center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
            console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
            console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );
            var objSize = findMax (size);
            var scaleSet = targetSize/objSize;
            var theObject =  new THREE.Object3D();
            theObject.add (object);
            object.scale.set (scaleSet, scaleSet, scaleSet);
            object.position.set (-center.x*scaleSet+x, -center.y*scaleSet + size.y/2*scaleSet+y, -center.z*scaleSet+z);
            return theObject;
            function findMax(v) {
                if (v.x > v.y) {
                    return v.x > v.z ? v.x : v.z;
                } else { 
                    return v.y > v.z ? v.y : v.z;
                } 
            }
        }
        
        function buildModel(){
            let geometry = new THREE.Geometry();
            let pos_y = 21, pos_x = 25, pos_z = -10;
            geometry.vertices.push(new THREE.Vector3(-2+pos_x, 0+pos_y, 2+pos_z));//0
            geometry.vertices.push(new THREE.Vector3(2+pos_x, 0+pos_y, 2+pos_z));//1
            geometry.vertices.push(new THREE.Vector3(2+pos_x, 9+pos_y, 2+pos_z));//2
            geometry.vertices.push(new THREE.Vector3(2+pos_x, 11+pos_y, 0+pos_z));//3
            geometry.vertices.push(new THREE.Vector3(-2+pos_x, 11+pos_y, 0+pos_z));//4
            geometry.vertices.push(new THREE.Vector3(-2+pos_x, 9+pos_y, 2+pos_z));//5
            geometry.vertices.push(new THREE.Vector3(2+pos_x, 0+pos_y, -2+pos_z));//6
            geometry.vertices.push(new THREE.Vector3(2+pos_x, 9+pos_y, -2+pos_z));//7
            geometry.vertices.push(new THREE.Vector3(-2+pos_x, 9+pos_y, -2+pos_z));//8
            geometry.vertices.push(new THREE.Vector3(-2+pos_x, 0+pos_y, -2+pos_z));//9
            geometry.vertices.push(new THREE.Vector3(2+pos_x, 12+pos_y, 0+pos_z));//10
            geometry.vertices.push(new THREE.Vector3(-2+pos_x, 12+pos_y, 0+pos_z));//11
            
            let face;
            face = new THREE.Face3(0, 1, 2), face.materialIndex = 0;
            geometry.faces.push(face);
            face = new THREE.Face3(0, 2, 5), face.materialIndex = 0;
            geometry.faces.push(face);
            
            face = new THREE.Face3(2, 3, 4), face.materialIndex = 1;
            geometry.faces.push(face);
            face = new THREE.Face3(2, 4, 5), face.materialIndex = 1;
            geometry.faces.push(face);
            face = new THREE.Face3(1, 6, 2), face.materialIndex = 2;
            geometry.faces.push(face);
            face = new THREE.Face3(6, 7, 2), face.materialIndex = 2;
            geometry.faces.push(face);
            
            face = new THREE.Face3(2, 7, 3), face.materialIndex = 3;
            geometry.faces.push(face);
            
            face = new THREE.Face3(6, 7, 8), face.materialIndex = 4;
            geometry.faces.push(face);
            face = new THREE.Face3(6, 8, 9), face.materialIndex = 4;
            geometry.faces.push(face);
            
            face = new THREE.Face3(7, 3, 8), face.materialIndex = 5;
            geometry.faces.push(face);
            face = new THREE.Face3(3, 4, 8), face.materialIndex = 5;
            geometry.faces.push(face);
            
            face = new THREE.Face3(8, 5, 9), face.materialIndex = 6;
            geometry.faces.push(face);
            face = new THREE.Face3(5, 0, 9), face.materialIndex = 6;
            geometry.faces.push(face);
            
            face = new THREE.Face3(8, 4, 5), face.materialIndex = 7;
            geometry.faces.push(face);
            
            face = new THREE.Face3(3, 10, 11), face.materialIndex = 8;
            geometry.faces.push(face);
            face = new THREE.Face3(11, 4, 3), face.materialIndex = 8;
            geometry.faces.push(face);
            
            face = new THREE.Face3(1, 6, 9), face.materialIndex = 9;
            geometry.faces.push(face);
            face = new THREE.Face3(0, 1, 9), face.materialIndex = 9;
            geometry.faces.push(face);
            
            let loader = new THREE.TextureLoader();
            loader.crossOrigin = ('');
            let texture_front = loader.load('./teafront.png');
            let texture_right = loader.load('./tearight.png');
            let texture_left = loader.load('./tealeft.png');
            let texture_back = loader.load('./teaback.png');
            let texture_frontup = loader.load('.upleft/.png');
            let texture_rightup = loader.load('./upright.png');
            let texture_leftup = loader.load('./tea_leftup.png');
            let texture_backup = loader.load('./tea_backup.png');
            
            texture_frontup.wrapS = THREE.RepeatWrapping;
            texture_frontup.repeat.x = - 1;
            
            texture_backup.wrapS = THREE.RepeatWrapping;
            texture_backup.repeat.x = - 1;
            
            texture_right.wrapS = THREE.RepeatWrapping;
            texture_right.repeat.x = - 1;
            
            texture_left.wrapS = THREE.RepeatWrapping;
            texture_left.repeat.x = - 1;
            
            texture_left.wrapT = THREE.RepeatWrapping;
            texture_left.repeat.y = - 1;
            
            
            materialArray = [];
            materialArray.push(
                new THREE.MeshPhongMaterial({map:texture_front, side:THREE.DoubleSide}),
                new THREE.MeshPhongMaterial({map:texture_frontup, side: THREE.DoubleSide}),
                new THREE.MeshPhongMaterial({map:texture_right, side: THREE.DoubleSide}),
                new THREE.MeshPhongMaterial({map:texture_rightup, side: THREE.DoubleSide}),
                new THREE.MeshPhongMaterial({map:texture_back, side: THREE.DoubleSide}),
                new THREE.MeshPhongMaterial({map:texture_backup, side: THREE.DoubleSide}),
                new THREE.MeshPhongMaterial({map:texture_left, side: THREE.DoubleSide}),
                new THREE.MeshPhongMaterial({map:texture_leftup, side: THREE.DoubleSide}),
                new THREE.MeshPhongMaterial({color:'white', side: THREE.DoubleSide}),
                new THREE.MeshPhongMaterial({color:'white', side: THREE.DoubleSide})
            );
            let tea_case = new THREE.Mesh(geometry, materialArray);
            tea_case.castShadow = true;
            tea_case.receiveShadow = true;
            return tea_case;
        }
        function init() {
		     width = window.innerWidth;
			 height = window.innerHeight;
			  
			  renderer = new THREE.WebGLRenderer({
				antialias: true
			  });
			  renderer.setSize(width, height);
			  document.body.appendChild(renderer.domElement);
			  renderer.setClearColor(0x888888);
			  
			  renderer.autoClear = false;
			  
			  camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
			  camera.position.y = 80;
			  camera.position.z = 400;
			  camera.lookAt(new THREE.Vector3(0, 0, 0));
			  
			  let controls = new THREE.OrbitControls(camera, renderer.domElement);


			  window.addEventListener('resize', onWindowResize, false);
			  function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			  }
            lit = true;
            roomlit = true;
            sceneGrey = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 300;

            var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
			var geometry = new THREE.CircleBufferGeometry( 50, 32 );
			var material = new THREE.MeshBasicMaterial( { color: 0x0000ff } );
			var circle = new THREE.Mesh( geometry, material );
            sceneGrey.add(gridXZ);
            //renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x888888);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            document.body.appendChild(renderer.domElement);
            
            ambient = new THREE.AmbientLight(0x444444);
            ambient.castShadow = true;
            //sceneGrey.add(ambient);
            
            directionalLight = new THREE.DirectionalLight(0xffffff);
            directionalLight.position.set(0, 1, 1).normalize();
            directionalLight.castShadow = true;
            sceneGrey.add(directionalLight);
            directionalLight.shadow.bias = -.01;
            
			renderTarget = new THREE.WebGLRenderTarget (width, height);  // full-size RT
            /////////////////////////////////////////////////////////////////////
			
			 /* sceneGrey = new THREE.Scene();
			  let floor = new THREE.Mesh (new THREE.PlaneGeometry (200,200), new THREE.MeshPhongMaterial());
			  floor.rotation.x = -Math.PI/2;*/
			  
			/*  var geometry = new THREE.TorusGeometry( 10, 3, 16, 100 );
			  var torus = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial({color: 'cyan'}) );
			  torus.position.set (40, 10, 30);
			  torus.rotation.x = Math.PI/2;
			  var box = new THREE.Mesh (new THREE.BoxGeometry (30, 40, 60), new THREE.MeshLambertMaterial({color: 'red'}));
			  box.position.set (-30, 20, -50);

			  sceneGreyGrey.add (floor, torus, box);*/
				
			  sceneGreyColor = new THREE.Scene();
			  var geometry = new THREE.TorusKnotGeometry( 10, 3, 100, 16 );
			  var material = new THREE.MeshLambertMaterial( { color: 'red' } );
			  var torusKnot = new THREE.Mesh( geometry, material );
			  //sceneGreyColor.add( torusKnot);
			  torusKnot.position.y = 20;
            // model
            var onProgress = function(xhr) {
                if (xhr.lengthComputable) {
                  var percentComplete = xhr.loaded / xhr.total * 100;
                  console.log(Math.round(percentComplete, 2) + '% downloaded');
                }
            };
            var onError = function(xhr) {};
            var mtlLoader = new THREE.MTLLoader();
            mtlLoader.setPath('Desklamp/');
            mtlLoader.load('Desklamp.mtl', function(materials) {
                materials.preload();
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Desklamp/');
                objLoader.load('Desklamp.obj', function(object) {
                    theObjectAll = unitize (object, -22, 21, -10, 20);
                    theObjectAll.children[0].castShadow = true;
                    theObjectAll.children[0].receiveShadow = true;
                    sceneGrey.add (theObjectAll);				
                    object.traverse (
                        function(mesh) {
                            if (mesh instanceof THREE.Mesh) {
                                mesh.material.side = THREE.DoubleSide;
                                
                            }
                        }
                    );
                }, onProgress, onError);
            });
            
            var onProgress2 = function(xhr) {
                if (xhr.lengthComputable) {
                  var percentComplete = xhr.loaded / xhr.total * 100;
                  console.log(Math.round(percentComplete, 2) + '% downloaded');
                }
            };
            var onError2 = function(xhr) {};
            var mtlLoader2 = new THREE.MTLLoader();
            mtlLoader2.setPath('chair/');
            mtlLoader2.load('chair.mtl', function(materials) {
                materials.preload();
                var objLoader2 = new THREE.OBJLoader();
                objLoader2.setMaterials(materials);
                objLoader2.setPath('chair/');
                objLoader2.load('chair.obj', function(object) {
                    theObjectChair = unitize (object, 10, -9.5, 40, 30);
					theObjectChair.children[0].position.set(0,10,30);
                    theObjectChair.children[0].rotation.y = -Math.PI;
                    sceneGrey.add (theObjectChair);
                    object.traverse (
                        function(mesh) {
                            if (mesh instanceof THREE.Mesh) {
                                mesh.material.side = THREE.DoubleSide;
                                mesh.castShadow = true;
                                mesh.receiveShadow = true;
                            }
                        }
                    );
                }, onProgress2, onError2);
            });
			//table
            var geometry = new THREE.BoxGeometry(70, 30, 2);
            var wallMeterial = new THREE.MeshLambertMaterial({color:0x3b240e});
            let desk_entry = new THREE.Mesh(geometry, wallMeterial);
            desk_entry.castShadow = true;
            desk_entry.receiveShadow = true;
            
            desk_things = []
            desk_entrys = []
            PosOfx = [0, 0, 0, 0],
            PosOfz = [0, 0, -100, 0],
            Rotation = [0, 1, 0, 1];
            for (let i = 0; i < 1; i++) {
                let desk = new Desk();
                desk_things.push(desk);
                let thisMesh = desk_entry.clone();
                if (i == 0) thisMesh.rotation.x = -Math.PI / 2;
                thisMesh.position.set(PosOfx[i], 20, PosOfz[i], Rotation[i]);
                desk_entrys.push(thisMesh);
                sceneGrey.add(thisMesh)
            }
            var sphere_geometry = new THREE.SphereGeometry( 2, 32, 32 );
            var sphere_material = new THREE.MeshPhongMaterial( {color: 0xffff00} );
            sphere = new THREE.Mesh( sphere_geometry, sphere_material );
            sphere.material.emissive = new THREE.Color('yellow');
            sphere.position.set(-19, 38, -10);
            sceneGrey.add( sphere );
			
			//wall
			 var geometry = new THREE.BoxGeometry(200, 50, 6);
			 var material = new THREE.MeshLambertMaterial({color:0x888888});
			 base = new THREE.Mesh(geometry, material);
			 base.position.set(0, 25, -100);
			 sceneGrey.add(base);
			 
			 var geometry = new THREE.BoxGeometry(206, 50, 6);
			 var material = new THREE.MeshLambertMaterial({color:0x888888});
			 base = new THREE.Mesh(geometry, material);
			 base.rotation.y = -Math.PI / 2
			 base.position.set(-100, 25, 0);
			 sceneGrey.add(base);
            
            
			
			//table4
			  var geometry = new THREE.BoxGeometry(2, 20, 2);
			  var material = new THREE.MeshLambertMaterial({color:0x3b240e});
			  base = new THREE.Mesh(geometry, material);
			  base.position.set(-34,10,-14);
			  sceneGrey.add(base);
			  
			  var geometry = new THREE.BoxGeometry(2, 20, 2);
			  var material = new THREE.MeshLambertMaterial({color:0x3b240e});
			  base = new THREE.Mesh(geometry, material);
			  base.position.set(-34,10,14);
			  sceneGrey.add(base);
			  
			  var geometry = new THREE.BoxGeometry(2, 20, 2);
			  var material = new THREE.MeshLambertMaterial({color:0x3b240e});
			  base = new THREE.Mesh(geometry, material);
			  base.position.set(34,10,-14);
			  sceneGrey.add(base);
			 
			  var geometry = new THREE.BoxGeometry(2, 20, 2);
			  var material = new THREE.MeshLambertMaterial({color:0x3b240e});
			  base = new THREE.Mesh(geometry, material);
			  base.position.set(34,10,14);
			  sceneGrey.add(base);
			 //pen
			 var texture = new THREE.TextureLoader().load( "textures/tea.jpg" );
			 texture.wrapS = THREE.RepeatWrapping;
			 texture.wrapT = THREE.RepeatWrapping;
			 texture.repeat.set( 4, 4 );
            //light
            desk_light = new THREE.PointLight(0xffffff, 0.9, 100); //,100
            desk_light.position.set(-19, 38, -10);
            desk_light.shadow.camera.near = 0.1;
            desk_light.shadow.camera.far = 200;
            sceneGrey.add(desk_light);
			///////////////////////////////////////////////////////////
		/*	  light = new THREE.PointLight( 0xffffff, 1);
			  light.position.set( 50, 50, 50 );
			  light2 = new THREE.PointLight( 0xffffff, 1);
			  
			  sceneGreyColor.add (light);
			  sceneGreyColor.add (new THREE.PointLightHelper (light,5))
			  sceneGreyGrey.add (light2);*/
			  
			  ////////////////////////////////////////////////////////////////////////
			sceneColor = new THREE.Scene();
            
            let kblue = new THREE.Vector3(0, 0, byab[0]);
            let kyellow = new THREE.Vector3(byab[1], byab[1], 0);
            let kd = new THREE.Vector3(255/255, 105/255, 105/255); //209, 63, 197
            let k_cool = kd.clone().multiplyScalar(byab[2]).add(kblue);
            let k_warm = kd.clone().multiplyScalar(byab[3]).add(kyellow);
//            teapotMaterial = new THREE.ShaderMaterial({
//              uniforms: {
//                lightpos: {type: 'v3', value: new THREE.Vector3(20, 300, 20)},
//                kcool:{type:'v3', value:k_cool}, //blue new THREE.Vector3(0, 0, 1)
//                kwarm:{type:'v3', value:k_warm}, //yellow
//                opacity: {type: 'f', value: 1.0}
//              },
//              vertexShader: document.getElementById('myVertexShader').textContent,
//              fragmentShader: document.getElementById('myFragmentShader').textContent
//            });
            teapotMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    lightpos: {
                        type: 'v3',
                        value: new THREE.Vector3(-20, 50, 0)
                    }
                },
                vertexShader: document.getElementById('myVertexShader').textContent,
                fragmentShader: document.getElementById('myFragmentShader').textContent
            });
            let tea_pot_mono = new THREE.Mesh (new THREE.TeapotBufferGeometry(3), teapotMaterial);
            sceneColor.add (tea_pot_mono);
            tea_pot_mono.position.z = -10;
            tea_pot_mono.position.y = 23.5;
            
            renderTarget = new THREE.WebGLRenderTarget (width, height);  // full-size RT
  
            ////////////////////////////////////////////////////////////////////////
			var uniforms = {
            imageSize: {
              type: 'v2',
              value: new THREE.Vector2(window.innerWidth, window.innerHeight)
            },
            texture: {
              type: 't',
              value: renderTarget.texture
            } ,
            };
            // sceneGrey0: for processing texture
            // camera0: full-screen ortho camera
            // plane0: mesh for texture processing
            sceneGrey0 = new THREE.Scene();;
            camera0 = new THREE.OrthographicCamera (0, width, height, 0,-10,100);
            var vertShader = document.getElementById('myVertexShader-mono').textContent;
            var fragShader = document.getElementById('myFragmentShader-mono').textContent;
            shaderMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertShader,
                fragmentShader: fragShader,
                depthTest: false,
                depthWrite: false
            });
            var plane0 = new THREE.Mesh (new THREE.PlaneGeometry(width, height), shaderMaterial);
            sceneGrey0.add (plane0);
            plane0.position.set (width/2, height/2, 0);
        }
        
        function animate() {
		//angle += 0.01;
		  /*requestAnimationFrame(animate);
		  light.position.set (40*Math.cos(angle), 60, 40*Math.sin(angle));
		  light2.copy (light);*/
		  
		  // render sceneGrey to renderTarget
		  renderer.setRenderTarget (renderTarget);
		  renderer.clear();  // clear the buffers of render target 

		  // normalMat.colorWrite = true;
		  sceneGrey.traverse ( function (obj) {
			if (obj instanceof THREE.Mesh)
				obj.material.colorWrite = true;
		  });
		  
		  renderer.render(sceneGrey, camera);

		  // switch to screen output    
		  renderer.setRenderTarget (null);
		  renderer.clearColor();  // clear screen buffers
		  renderer.render(sceneGrey0, camera0);
		  
		  // set up blockers from sceneGrey (colorWrite is disabled)
		  // normalMat.colorWrite = false;
		  sceneGrey.traverse ( function (obj) {
			if (obj instanceof THREE.Mesh)
				obj.material.colorWrite = false;
		  });
		 renderer.render (sceneGrey, camera);
		  
		  // render sceneColor
		  renderer.render(sceneColor, camera);
        }
    </script>
</body>

</html>

